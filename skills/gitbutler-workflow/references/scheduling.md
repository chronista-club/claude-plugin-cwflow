# 混在サイズ並行開発フロー

XS〜XLの5サイズのタスクを、ccセッション並行度2-3で効率的に処理するフロー設計。

## Claude Codeへの指示

このセクションはccが直接従うべきルール。

### タスクを受け取ったら

1. **サイズを判定する**:
   - XS（~1コミット、5-10分）: typo修正, 設定変更
   - S（2-5コミット、~1時間）: 小機能, バグ修正
   - M（5-15コミット、2-4時間）: 中機能
   - L（15-30コミット、~1日）: 大機能
   - XL（30+コミット、数日）: アーキテクチャ変更

2. **サイズ別の行動規則**:

   **XS/S** → 即座に実行。複数あればバッチ処理（1セッションで連続実行）
   ```bash
   # XSバッチ例
   but branch new fix/batch-xs
   # 修正1, 修正2, 修正3 を連続実行
   but commit -m "fix: batch XS fixes"
   but push && but publish
   ```

   **M** → 単独ブランチで実行。完了後すぐPR
   ```bash
   but branch new feat/feature-name
   # 実装
   but absorb
   but push && but publish
   ```

   **L** → 着手前に `but status` で他ブランチとの衝突可能性を確認
   ```bash
   but status -f  # 他ブランチの変更ファイルを確認
   but branch new feat/large-feature
   # 実装（必要に応じて途中で but absorb + but push）
   ```

   **XL** → **必ずstacked branchesで分解してから着手**
   ```bash
   # まず計画を立てる: 3-5 phaseに分割
   but branch new xl/phase-1-data-model
   but branch new -a xl/phase-1-data-model xl/phase-2-api
   but branch new -a xl/phase-2-api xl/phase-3-integration
   # phase-1 から順に実装
   # 各phase完了時に but push && but publish
   ```

3. **複数タスクを並列実行する指示を受けたら**:
   - 変更ファイルが重ならない組み合わせを選ぶ
   - 重なる場合は `but mark` でファイルパターンを事前割り当て
   - 大物同士の並列は避ける（L+L, L+XL, XL+XL は禁止）
   - 推奨: 大(L/XL) + 中(M) + 小バッチ(XS/S)

4. **作業の区切りごとに**:
   ```bash
   but absorb    # 変更を最適コミットに吸収
   but status -f # 全体確認
   ```

---

## 背景理論（人間向け運用ガイド）

以下はスケジューリング戦略の理論的背景。ccが直接参照する必要はないが、
人間がワークフローを設計する際の判断材料。

### タスクサイズ定義

| サイズ | コミット数 | 推定時間 | 例 |
|---|---|---|---|
| XS | ~1 | 5-10分 | typo修正, 設定変更, 依存更新 |
| S | 2-5 | 30分-1時間 | 小機能, バグ修正, テスト追加 |
| M | 5-15 | 2-4時間 | 中機能, リファクタリング |
| L | 15-30 | 1日 | 大機能, API全体設計 |
| XL | 30+ | 2-5日 | アーキテクチャ変更, フレームワーク移行 |

### 制約

- **並行度**: 最大3 ccセッション同時
- **人間の注意力**: 同時に監視できるのは実質2-3セッション
- **GitButlerの限界**: Virtual Branch 5-6本が管理限界の目安
- **コンフリクト確率**: 並行ブランチ数 × タスクサイズに比例して増加

## 核心的な洞察

### スケジューリング理論からの知見

これは本質的に**ジョブショップ・スケジューリング問題**に帰結する。
並行度P=3のマシンで、異なる処理時間のジョブを最短完了時間で処理する問題。

**LPT（Longest Processing Time first）の逆が最適ではない**理由：
- 大タスクは分割可能（stacked branches）
- 小タスクはバッチ処理可能
- コンフリクトリスクが非線形に増大する

最適解は **層分離 + パイプライン** 方式になる。

### コンフリクトの物理学

同時に走るブランチのコンフリクト確率は、変更ファイルの重なりに依存する。

```
P(conflict) ≈ 1 - (1 - f₁∩f₂/F)^c
  f₁∩f₂: 2ブランチの変更ファイル共通集合
  F: 全ファイル数
  c: コミット数の積
```

→ **大きいタスク同士の並行が最も危険**
→ **大+小 の組み合わせが最も安全**

---

## パターン1: 有限バッチ（50個の場合）

50タスク = XS:10, S:10, M:10, L:10, XL:10

### 戦略: 三層パイプライン

3つのccスロットを役割で分離する：

```
Slot A: 大物担当（L/XL） — 1タスクを深く
Slot B: 中物担当（M）   — 1タスクを集中
Slot C: 小物バッチ（XS/S）— 複数タスクを連続処理
```

この分離が最適な理由：
1. 大タスクは長時間走る → 他スロットを止めない
2. 小タスクは高速に回転する → スループット確保
3. 中タスクは独立に進行する → 大物のコンフリクトリスクを回避

### Phase 1: XLの分解（準備フェーズ）

XL（30+コミット）は1本のブランチで扱わない。stacked branchesで3-5段に分解する。

```bash
# XL-1 を3段スタックに分解
but branch new xl-1/phase-1-data-model
but branch new -a xl-1/phase-1-data-model xl-1/phase-2-api
but branch new -a xl-1/phase-2-api xl-1/phase-3-integration
```

→ 各phaseがM相当（5-15コミット）になる
→ phase-1完了時点でPR → レビュー → マージ可能
→ XL×10 ≈ M×30-50 相当に正規化される

### Phase 2: 実行スケジュール

**Week 1-2: 大物の基盤 + 小物の一掃**

```
Day 1:
  Slot A: XL-1/phase-1 (cc session, ~4h)
  Slot B: M-1 (cc session, ~3h)
  Slot C: XS-1→XS-2→XS-3→S-1→S-2 (連続バッチ, ~3h)

Day 2:
  Slot A: XL-1/phase-2 (phase-1完了後に開始)
  Slot B: M-2
  Slot C: XS-4→XS-5→S-3→S-4→S-5

Day 3:
  Slot A: XL-1/phase-3 → XL-2/phase-1
  Slot B: M-3
  Slot C: XS-6→XS-7→XS-8→S-6→S-7
```

**小物バッチの実行方法：**

```bash
# Slot Cでの連続バッチ実行
# XSはcc 1セッションで複数処理可能

cc "以下のXSタスクを順番に実行:
  1. README.mdのtypo修正
  2. .envのデフォルト値更新
  3. CI設定のNode.jsバージョン更新"
# → 1セッションで3つのXSを処理
# → GitButlerが各変更を1ブランチにまとめる or 分割
```

**中物の独立実行：**

```bash
# Slot B: M単独実行
cc "feat: ユーザープロフィール画像のアップロード機能を実装"
# → 5-15コミットで完結
# → 完了次第 but publish でPR
```

### Phase 3: マージとbase更新

PRがマージされたら速やかにbaseを更新する。
これが溜まるとコンフリクトリスクが急増する。

```bash
# 毎日の始まりと、PRマージ後に実行
but pull
but status
```

### 50タスクの完了見積もり

```
XS × 10: Slot Cで2-3日分のバッチ
S  × 10: Slot Cで3-4日分のバッチ
M  × 10: Slot Bで10日
L  × 10: Slot Aで10日（Lは分解不要、1日1個）
XL × 10: Slot Aで20-30日（各XL = 2-3日、Lと直列）

全体: 約3-4週間（実稼働日20日として）
```

### 最適化のレバー

1. **小物のバッチサイズ調整**: XSを1セッションで5個まとめると、Slot Cの回転が速くなる
2. **Slot A/Bの動的切替**: Slot AのXL phase間にLを挟む（phase-1のPR待ち中にL-1着手）
3. **PRマージのパイプライン化**: phase-1マージ → phase-2プッシュ を並列化

---

## パターン2: 無限ストリーム（永続的に続く場合）

タスクが終わりなく流入し続ける定常状態の運用。

### 戦略: カンバン + 優先度キュー

有限バッチと根本的に異なるのは、**スループットの定常化**が目標になること。
全50個の完了時間を最小化するのではなく、単位時間あたりの処理量を最大化する。

### WIP制限

```
┌──────────────────────────────────────────────┐
│ Backlog → Ready → In Progress → Review → Done │
│          (∞)     (WIP: 3+2)    (WIP: 3)       │
└──────────────────────────────────────────────┘
```

- **In Progress**: ccセッション3本 + 人間レビュー2本 = WIP 5
- **Review**: PRが3本を超えたらIn Progressを止めてレビュー消化

### スロット割り当てポリシー

固定割り当てではなく、**優先度ベースのディスパッチ**を使う：

```
スロット空き発生時の選択ロジック:

1. 緊急（hotfix）があれば最優先
2. XLのphaseが中断中なら継続（コンテキストスイッチのコスト回避）
3. それ以外は SJF（Shortest Job First）で選択
   → XS/S を優先的に消化
   → ただし Lキュー/XLキューが3個以上溜まったら1個処理
```

**SJFが最適な理由**: 平均待ち時間（平均リードタイム）を最小化する。
直感的にも、5分で終わるXSの後ろに1日かかるLが控えている場合、
XSを先に片付けた方が全体の「完了タスク数/時間」が高くなる。

### Starvation防止

純粋なSJFはL/XLが永遠に後回しになる（starvation問題）。
これを防ぐために **Aging** を導入する：

```
実効優先度 = 基本優先度(サイズ) + 待ち時間ボーナス

基本優先度:  XS=5, S=4, M=3, L=2, XL=1
Aging:       キューに入ってからの経過日数 × 1.5

例: キューに3日待ったL
  = 2 + (3 × 1.5) = 6.5 → XSの5を超える → 次に処理される
```

### 1日のリズム

```
朝 (9:00):
  but pull
  but status
  but branch list --review
  → PRがあればレビュー・マージ
  → 空きスロットにキューの先頭をディスパッチ

午前 (9:30-12:00):
  Slot A: L/XL phase（深い作業）
  Slot B: M（集中作業）
  Slot C: XS/Sバッチ（高速回転）
  → 完了したら即 but push → but publish

昼休み:
  → detachしてccを走らせたまま離席可

午後 (13:00-17:00):
  → 完了したスロットに次タスクをディスパッチ
  → Slot CのXS/Sが枯渇したらMを投入
  → PRレビューが溜まっていたら1スロット止めてレビュー

夕方 (17:00):
  but status -f  → 全体確認
  but push       → 未プッシュ分をまとめてプッシュ
  → 長時間タスクはdetachして夜間走行
```

### 定常状態のスループット見積もり

```
1日あたりの処理能力（Slot 3本 × 8h）:

XS: 8-10個/日（Slot C集中時）
S:  4-5個/日（Slot C集中時）
M:  2-3個/日（Slot B + 空きSlot）
L:  1個/日（Slot A）
XL: 0.3-0.5個/日（Slot A、2-3日かかる）

混在時の実効スループット:
  XS:2 + S:1 + M:1 + L:0.5 + XL:0.2 ≈ 5タスク/日
```

### バックプレッシャー

タスク流入速度 > 処理速度 の場合、キューが無限に膨らむ。
これを検知して対処する：

```
警告閾値:
  Backlogが20個超 → タスクの受入を制限 or 優先度の低いものを棚上げ
  WIP 5個が常に埋まっている → 並行度を上げるか、タスク粒度を小さく

GitButler側の指標:
  but branch list | wc -l > 8 → ブランチが多すぎ、マージを優先
```

---

## 共通原則

### XLの分解ルール

XLを放置すると他の全てをブロックする。必ず分解する：

```
XL（30+コミット、数日）
  ↓ 分解
Phase 1: データ層（M相当、5-15コミット）
Phase 2: ロジック層（M相当）
Phase 3: インテグレーション（M相当）
  ↓ 各phaseが独立してPR可能
```

分解基準：
- 各phaseが単独でビルド・テスト可能なこと
- phaseの依存関係が一方向（stacked branches）であること
- 1 phaseが4時間以内に完了すること

### コンフリクト最小化の組み合わせ

同時並行するタスクは「変更領域が重ならない」ことが最重要。

```
良い組み合わせ:
  Slot A: backend/auth（認証モジュール）
  Slot B: frontend/dashboard（UI）
  Slot C: infra/ci（CI設定）
  → ファイル重なりがほぼゼロ

悪い組み合わせ:
  Slot A: backend/auth（認証）
  Slot B: backend/user（ユーザー管理）
  → User ↔ Auth の共通ファイル（models, middleware）で衝突
```

タスク選択時に `but mark` で事前にファイルパターンを割り当てると安全：

```bash
but mark "src/auth/*" branch-auth
but mark "src/dashboard/*" branch-dashboard
```

### PRマージのタイミング

```
マージ頻度の黄金律:
  - XS/S: 完了即マージ（PRレビュー不要 or セルフマージ）
  - M: 当日中にマージ
  - L: 翌日中にマージ
  - XL phase: phase完了後2日以内にマージ

遅延するとどうなるか:
  - 未マージPRが3本超 → but pull時のrebaseコンフリクト急増
  - 1週間放置 → ほぼ確実にコンフリクト発生
```

### バッチ処理のコツ

XS/SをSlot Cで高速回転させるためのテクニック：

```bash
# 1. 同種タスクをまとめて1セッションで処理
cc "以下のtypo修正を全て実行:
  - README.mdの'recieve' → 'receive'
  - src/config.tsの古いコメント削除
  - package.jsonのdescription更新"

# 2. 完了後の一括整理
but absorb        # 未コミット変更を適切なコミットへ
but push          # まとめてプッシュ
but publish       # まとめてPR作成

# 3. 次のバッチへ即座に移行
cc "次のバッチ: S-4, S-5のバグ修正を実行..."
```
